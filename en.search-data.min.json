[{"id":0,"href":"/hermit/sdks/","title":"Supported SDKs","parent":"Hermit","content":"As of early 2021 Hermit has support for the following language SDKs.\nSDK Status Crystal Crystal is a general-purpose, object-oriented programming language with a Ruby-inspired syntax. Elm Elm is distributed as a single binary, so everything works as you would expect! Flutter (Dart) Flutter is available, though not well tested. GraalVM GraalVM is supported and reasonably well tested. Go Hermitised Go is isolated, though uses the global Go cache (~/go) for performance/utilisation considerations. ${GOBIN} is set to ${HERMIT_ENV}/.hermit/go/bin and is included in the ${PATH}. Haskell (GHC) GHC and Cabal are both available though not well tested. Java Java (OpenJDK) is supported and well tested, including Zulu builds. Kotlin Kotlin is supported and well tested. Node Packages are completely isolated within the Hermit environment. Global packages (npm install -g) are installed into ${HERMIT_ENV}/.hermit/node while local packages are installed in ${HERMIT_ENV}/node_modules. bin directories for both global and local packages are added to the ${PATH}. Python Python is fully supported and isolated. Python packages installed within an active Hermit environment will be located in ${HERMIT_ENV}/.hermit/python and ${HERMIT_ENV}/.hermit/python/bin is added to the ${PATH}. Rust Rust stable and nightly are both supported along with all standard tooling. Nightly will be updated daily. TinyGo A Go Compiler For Small Places. Zig Zig is supported and works as expected, though not well tested. "},{"id":1,"href":"/hermit/usage/","title":"Usage","parent":"Hermit","content":"This documentation describes how to use Hermit within your own projects.\nGet Started Environment variables Package management Recipes / Patterns Editor / IDE Integration Shell Integration Configuration User Configuration Continuous Integration Updating Renovate "},{"id":2,"href":"/hermit/usage/get-started/","title":"Get Started","parent":"Usage","content":"This document gives a brief introduction to installing Hermit and using a newly created environment.\nInstalling Hermit Installing Hermit is straightforward:\ncurl -fsSL https://github.com/cashapp/hermit/releases/download/stable/install.sh | /bin/bash This will download and install hermit into ~/bin. You should add this to your $PATH if it isn't already.\nAlso consider installing the shell hooks to get automatic environment activation/deactivation when changing directories. Initialising a Project Change into a project directory and run the following:\n~$ cd ~/project ~/project$ hermit init info: Creating new Hermit environment in /home/user/project ... At this point the Hermit environment should be initialised and the ./bin directory should contain something like the following:\nREADME.hermit.md activate-hermit hermit hermit.hcl Activating an Environment Activating an environment will add its bin directory to your $PATH, as well as setting any environment variables managed by Hermit.\nTo activate a Hermit environment source the activate-hermit script:\n~/project$ . ./bin/activate-hermit Hermit environment /home/user/project activated projectüêö~/project$ Once activated the shell prompt will change to include the prefix \u0026lt;environment\u0026gt;üêö.\nAt this point you can use and manage packages in this environment.\nSearching for packages Once your environment is activated, use hermit search to search for packages. Without arguments it will list all known packages, or you may pass a term to search in package names and descriptions.\nprojectüêö~/project$ hermit search openjdk openjdk (11.0.11_9-zulu11.48.21, @stable, @zulu, 11.0.8_10, 11.0.9_11, 11.0.10_9) Java is a class-based, object-oriented programming language. Installing a package After you've selected the package you'd like to install into your environment, use hermit install to install packages:\nprojectüêö~/project$ hermit install go-1.16.3 projectüêö~/project$ go version go version go1.16.3 darwin/amd64 Refer to the package management documentation for more details, including how to uninstall, information about channels, etc.\nDeactivating an Environment When an environment is activated, Hermit inserts a shell function deactivate-hermit. Call this to deactivate the current environment.\nprojectüêö~/project$ deactivate-hermit Hermit environment /home/user/project deactivated ~/project$ "},{"id":3,"href":"/hermit/usage/envars/","title":"Environment variables","parent":"Usage","content":"When a Hermit environment is active, environment variables will be set by Hermit itself, the command-line, the active environment, and installed packages, in that order.\nHermit Hermit prefixes all of its own variables with HERMIT_ or _HERMIT_. While it uses a bunch of variables internally, two you can rely on to always be present in an active environment are:\nName Description HERMIT_ENV Path to the active Hermit environment. HERMIT_BIN Path to the active Hermit environment bin directory. An empty environment might look something like the following:\nprojectüêö~/project$ hermit env HERMIT_BIN=/home/user/project/bin HERMIT_ENV=/home/user/project PATH=/home/user/project/bin:/home/user/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/local/bin Command-line Use the flag --env=NAME=value to set per-invocation environment variables.\nActive Environment The active environment may define additional environment variables in bin/hermit.hcl. These can be managed with the hermit env command, or by directly editing the configuration file.\nFor example, to set GOBIN to a build directory within the environment:\nprojectüêö~/project$ hermit env GOBIN \u0026#39;${HERMIT_ENV}/build\u0026#39; projectüêö~/project$ hermit env GOBIN=/home/user/project/build GOROOT=/home/user/.cache/hermit/pkg/go-1.16 ... projectüêö~/project$ echo $GOBIN /home/user/project/build The bin/hermit.hcl file will contain:\n# Extra environment variables. env = { \u0026#34;GOBIN\u0026#34;: \u0026#34;${HERMIT_ENV}/build\u0026#34;, } Use the hermit env command to view and set per-environment variables:\nUsage: hermit env [\u0026lt;name\u0026gt;] [\u0026lt;value\u0026gt;] Manage environment variables. Without arguments the \u0026#34;env\u0026#34; command will display environment variables for the active Hermit environment. Passing \u0026#34;\u0026lt;name\u0026gt;\u0026#34; will print the value for that environment variable. Passing \u0026#34;\u0026lt;name\u0026gt; \u0026lt;value\u0026gt;\u0026#34; will set the value for an environment variable in the active Hermit environment.\u0026#34; Arguments: [\u0026lt;name\u0026gt;] Name of the environment variable. [\u0026lt;value\u0026gt;] Value to set the variable to. Flags: -r, --raw Output raw values without shell quoting. --activate Prints the commands needed to set the environment to the activated state --deactivate Prints the commands needed to reset the environment to the deactivated state -i, --inherit Inherit variables from parent environment. -n, --names Show only names. -u, --unset Unset the specified environment variable. Take care to only use single quotes (') when setting values so that the shell doesn't interpolate environment variables before Hermit. ie. Do not do this:\nprojectüêö~/project$ hermit env GOBIN \u0026#34;${HERMIT_ENV}/build\u0026#34; as it will result in this bin/hermit.hcl:\n# Extra environment variables. env = { \u0026#34;GOBIN\u0026#34;: \u0026#34;/home/user/project/build\u0026#34;, } This will of course work fine for the local user, but will fail tragically for anyone else.\nInstalled Packages Packages may export environment variables for convenience or in order to operate correctly. For example, the go package sets the GOROOT to the location of the installed Go SDK:\nprojectüêö~/project$ hermit install go projectüêö~/project$ hermit env GOROOT=/home/user/.cache/hermit/pkg/go-1.16 ... "},{"id":4,"href":"/hermit/usage/management/","title":"Package management","parent":"Usage","content":"This document describes how packages within a Hermit environment can be found, installed, and managed. Packages are defined in configuration files called manifests which are retrieved from collections of manifests called manifest sources which in turn are commonly (but not always) Git repositories.\nKeeping up to Date Hermit retrieves package manifests from various locations, including Git repositories. It will periodically sync these repositories to your system to ensure you have the most up to date manifests. Similarly, Hermit will periodically update itself and packages installed by channel. You can force this by running:\nprojectüêö~/project$ hermit update Searching for Packages Search for packages with the search command, optionally passing a substring to match within the package name or description:\nprojectüêö~/project$ hermit search rust rust (@nightly, 1.51.0) A language empowering everyone to build reliable and efficient software. Selecting Packages Packages can be selected in one of three ways:\nBy version - \u0026lt;package\u0026gt;-\u0026lt;version\u0026gt;\nA specific version of a package can be installed by specifying \u0026lt;package\u0026gt;-\u0026lt;version\u0026gt;. eg. hermit install rustc-1.51.0\nBy channel - \u0026lt;package\u0026gt;@\u0026lt;channel\u0026gt;\nChannels can be explicitly selected with \u0026lt;package\u0026gt;@\u0026lt;channel\u0026gt;, eg. hermit install rustc@nightly. Channels are automatically updated at a frequency defined by the package manifest.\nBy preferred version - \u0026lt;package\u0026gt;\nWhen specifying just a package name, ie. \u0026lt;package\u0026gt;, the preferred version will be installed. The preferred version is, in order of priority:\nThe version specified as the default in the manifest. The latest stable version. The latest unstable version. The last channel, alphabetically. Installing Packages To install the latest stable version of protoc and the nightly channel of rust:\nprojectüêö~/project$ hermit install rust@nightly protoc At this point if you ls bin you will see something like the following:\nprojectüêö~/project$ ls bin README.hermit.md clippy-driver@ rust-analyzer@ rustc@ activate-hermit* hermit* rust-demangler@ rustdoc@ cargo@ hermit.hcl rust-gdb@ cargo-clippy@ miri@ rust-gdbgui@ cargo-miri@ protoc@ rust-lldb@ List Installed Packages To list packages installed in the active environment:\nprojectüêö~/project$ hermit list protoc (3.14.0) protoc is a compiler for protocol buffers definitions files. rust (@nightly) A language empowering everyone to build reliable and efficient software. Package Information You can obtain more detailed package information with hermit info \u0026lt;package\u0026gt;, eg.\nprojectüêö~/project$ hermit info rust hermit info rust@nightly Name: rust Channel: nightly Description: A language empowering everyone to build reliable and efficient software. State: installed Last used: 3m36.889138s ago Source: https://static.rust-lang.org/dist/rust-nightly-x86_64-apple-darwin.tar.xz Root: /home/user/.cache/hermit/pkg/rust@nightly Binaries: cargo cargo-clippy clippy-driver cargo-miri miri rust-analyzer rust-demangler rust-gdb rust-gdbgui rust-lldb rustc rustdoc Upgrading Packages For package channels or versions that adhere to semantic versioning, Hermit will automatically upgrade to the latest minor version using the hermit upgrade command:\nprojectüêö~/project$ hermit upgrade rust projectüêö~/project$ rustc --version rustc 1.51.0 (2fd73fabe 2021-03-23) Downgrading / Changing Versions To downgrade or switch to a specific version, use hermit install to explicitly specify the version. eg.\nprojectüêö~/project$ hermit install rust-1.50.0 projectüêö~/project$ rustc --version rustc 1.50.0 (940f2a77 2021-01-02) Uninstalling Packages Use hermit uninstall:\nprojectüêö~/project$ hermit uninstall rust "},{"id":5,"href":"/hermit/usage/recipes/","title":"Recipes / Patterns","parent":"Usage","content":"Patterns for solving common problems.\nPin to a major or minor version Reusing shell scripts across multiple projects Shell script \u0026quot;libraries\u0026quot; Pin to a major or minor version Each Hermit package includes a @latest channel, which is the latest stable version. One downside to this is that if a new major version is released, potentially including breaking changes, Hermit will use that as the version.\nTo solve this problem Hermit also creates channels for each (major) and (major, minor) version tuple. For example:\n$ hermit search -s \u0026#39;^go$\u0026#39; | grep \u0026#39;go@[0-9]\u0026#39; go@1 go@1.13 go@1.14 go@1.15 go@1.16 go@1.17 In Go's case, a minor (1.17 -\u0026gt; 1.18) version bump can be a bit rocky, so we might want to pin to the current stable minor version:\n$ hermit install go@1.17 This will track the latest point release of Go 1.17.\nReusing shell scripts across multiple projects In large multi-repo environments, it's common to have sets of shell scripts that are shared across projects. Anything from setting up and pushing Docker images to ECR, to linting in a consistent way, to validating .proto files, and so on.\nOne solution to this is to have a git repository containing the scripts, cloned down by each project. The main issue here is versioning. Either the mainline branch is used, which exposes users directly to bugs, or a specific tagged version is be used, which relies on consumers updating those tags as the scripts are updated.\nHermit can solve this problem nicely with its support for git cloned packages:\ndescription = \u0026#34;Our common scripts\u0026#34; binaries = [\u0026#34;*.sh\u0026#34;] source = \u0026#34;https://github.com/my-org/common-scripts.git#v${version}\u0026#34; version \u0026#34;0.1.0\u0026#34;, \u0026#34;0.1.1\u0026#34;, \u0026#34;0.2.0\u0026#34; {} channel tip { update = \u0026#34;1h\u0026#34; source = \u0026#34;https://github.com/my-org/common-scripts.git\u0026#34; } This provides semantic versioning for our library of scripts. Consumers can pin to a major or minor version to get stability, but test repositories can opt in to the \u0026quot;tip\u0026quot; channel to get the bleeding edge.\nShell script \u0026quot;libraries\u0026quot; With a bit of creativity, Hermit can help share libraries of scripts to be used by other scripts. Add a my-script-lib-prefix to your library to report its install directory. This is somewhat akin to pkg-config.\n#!/bin/bash echo \u0026#34;$(dirname $0)\u0026#34; Then expose this as a binary in the Hermit package:\ndescription = \u0026#34;My script lib\u0026#34; binaries = [\u0026#34;my-script-lib-prefix\u0026#34;] source = \u0026#34;https://github.com/my-org/my-script-lib.git#v${version}\u0026#34; version \u0026#34;0.1.0\u0026#34;, \u0026#34;0.1.1\u0026#34;, \u0026#34;0.2.0\u0026#34; {} Then to source any of the \u0026quot;library\u0026quot; scripts just install the package and:\n#!/bin/bash . $(my-script-lib-prefix)/lib1.sh # Use definitions from lib1.sh` "},{"id":6,"href":"/hermit/usage/ide/","title":"Editor / IDE Integration","parent":"Usage","content":" JetBrains - IntelliJ, GoLand Due to the way JetBrains IDE plugin APIs are designed, specific support for each language has to be built into the plugin. Currently, only the JDK and Go are supported. To install the plugin, search for the \u0026quot;Hermit\u0026quot; plugin from the Plugin Marketplace in the IDE Preferences \u0026gt; Plugin view, and install it.\nWhen you open a Hermit managed project, a dialog is shown asking if you want to enable the plugin for the project. If you select \u0026quot;yes\u0026quot;, the plugin is configured for your project.\nThe plugin will automatically configure Go and Java SDKs to work with the IDE, including Run Configurations, tests, and the builtin terminal.\nTerminal-based Editors Terminal based editors should Just Work‚Ñ¢Ô∏è if launched after a Hermit environment is activated.\nMac GUI Editors (Workaround) For other editors and IDEs, the best solution in lieu of native plugins is to open up a terminal, activate the Hermit environment, then launch the editor from the terminal. This is not ideal, but does work until a plugin is available.\nClose your editor. From a terminal activate your Hermit environment: . ./bin/activate-hermit Launch your editor from the terminal: Editor Launch command Sublime subl -nd . Visual Studio Code code . At this point your editor should be running with environment variables from the Hermit environment.\nOther Some IDEs/editors have support for configuring environment variables explicitly. In this case you can use hermit env to dump a machine-readable list of the environment variables Hermit manages. This can then be configured in your IDE.\nNote that if you add/remove packages from your Hermit environment you will need to reconfigure your IDE to pick up any changes to environment variable. "},{"id":7,"href":"/hermit/usage/shell/","title":"Shell Integration","parent":"Usage","content":" Tracking Environment Variables When a Hermit environment is activated, Hermit will install a shell hook to keep your shell's environment variables synchronised with Hermit's environment variables as you add and remove packages. This hook executes prior to each command.\nShell Hooks Hermit can also install shell integration hooks to provide\nAutomatic environment activation / deactivation of Hermit environments as you change directories in your terminal. Shell completion for the Hermit commands and packages Zsh This will install Hermit hooks into your ~/.zshrc file. Restart your shell in order for the changes to take effect.\nhermit shell-hooks --zsh To enable the ZSH command completion, you also need to manually initialise the completion system. A simple example on how to do this is to add this to your ~/.zshrc file, before the Hermit hooks:\nautoload -U compinit \u0026amp;\u0026amp; compinit -i See the ZSH Documentation for more information\nBash This will install Hermit hooks into your ~/.bashrc file. Restart your shell in order for the changes to take effect.\nhermit shell-hooks --bash "},{"id":8,"href":"/hermit/usage/config/","title":"Configuration","parent":"Usage","content":"Each Hermit environment contains a bin/hermit.hcl file that can be used to customise that Hermit environment.\nAttributes Attribute Type Description env {string:string}? Extra environment variables. sources [string]? Package manifest sources in order of preference. manage-git bool? Whether Hermit should manage Git. Per-environment Sources Hermit supports three different manifest sources:\nGit repositories; any cloneable URI ending with .git, eg.https://github.com/cashapp/hermit-packages.git. An optional #\u0026lt;tag\u0026gt; suffix can be added to checkout a specific tag. Local filesystem, eg. file:///home/user/my-packages.This is mostly only useful for local development and testing. Environment relative, eg. env:///my-packages.This will search for package manifests in the directory ${HERMIT_ENV}/my-packages. Useful for local overrides. "},{"id":9,"href":"/hermit/usage/user-config/","title":"User Configuration","parent":"Usage","content":"User's can override certain global behaviours of Hermit by creating a ~/.hermit.hcl file adhering to the following schema:\n1 2 3 4 5 6 7 8 # Modify prompt to include hermit environment (env), just an icon (short) or nothing (none) prompt = string # (optional) # If true use a short prompt when an environment is activated. short-prompt = boolean # (optional) # If true Hermit will never add/remove files from Git automatically. no-git = boolean # (optional) # If true Hermit will try to add the IntelliJ IDEA plugin automatically. idea = boolean # (optional) "},{"id":10,"href":"/hermit/usage/ci/","title":"Continuous Integration","parent":"Usage","content":"Generally, using Hermit in CI is similar to using it locally - activate your environment via . ./bin/activate-hermit, add \u0026lt;repo\u0026gt;/bin to your $PATH, or use ./bin/hermit env to directly update your CI environment.\nGitHub Actions Using Hermit in GitHub Actions is straightforward. Just add the following step to each job:\n- name: Init Hermit run: ./bin/hermit env --raw \u0026gt;\u0026gt; $GITHUB_ENV eg.\non: push: branches: - master pull_request: name: CI jobs: test: name: Test runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v2 - name: Init Hermit run: ./bin/hermit env -r \u0026gt;\u0026gt; $GITHUB_ENV - name: Test run: go test ./... Jenkins Here's an example Jenkinsfile to use Hermit inside Jenkins:\npipeline { agent any stages { stage(\u0026#39;Do stuff\u0026#39;) { environment { hermitEnvVars = sh(returnStdout: true, script: \u0026#39;./bin/hermit env --raw\u0026#39;).trim() } steps { withEnv(hermitEnvVars.split(\u0026#39;\\n\u0026#39;).toList()) { // now we can use any hermit package directly... sh \u0026#39;go build\u0026#39; } } } } } "},{"id":11,"href":"/hermit/usage/updates/","title":"Updating","parent":"Usage","content":"Hermit is designed in such a way that it and its package manifests are always on the latest version. To that end, Hermit will check for and upgrade to new releases of itself once every 24 hours, and will sync to the latest package definitions every 24 hours. If you notice a pause when using Hermit, this is often the cause.\nYou can read more about the implications of this on package maintenance in the packaging introduction.\nIn addition, some packages may define channels which allow packages to be kept up to date automatically with upstream releases. Channels specify their own update frequency which Hermit will use to periodically check for updates. If the ETag for the package has changed, Hermit will download and upgrade the package.\n"},{"id":12,"href":"/hermit/usage/renovate/","title":"Renovate","parent":"Usage","content":"Renovate is an open source dependency update tools. It supports the followings:\nUpdate Hermit Packages Using Hermit as a source of Binaries Update Hermit Packages Package update with Renovate ensures updates are done explicitly to the code repository via code commits. Together with proper default branch protection setup \u0026amp; CI pipeline steps, it can prevent breaking hermit package update flows into the repository, which is always a problem in the implicit package update using Channel.\nEnable Hermit Manager To start using Renovate for Hermit package updates, you will need to add hermit to the enabledManagers option in the Renovate repository config.\n{ enabledManagers: [\u0026#34;hermit\u0026#34;] } Private Packags If you are using Private Packages, You will need to configure the followings:\nDatasource Registry Url to make Hermit in Renovate to use the correct sources of packages. Github Token for Hermit to make sure Hermit has proper access when downloading packages. Hermit as Binary Source Renovate provides different ways to specify the source of binaries of the package managers, which satisfies different needs across the Renovate community.\nWith the ability to specify hermit as a binary source for Renovate, an extra level of flexibility is provided to Renovate. The benefits are listed as follows:\nUse exact version of package manager in a repository. (as opposite to the Go binary version) Allows different package manager versions across all repositories managed by the given Renovate instance Supports package managers outside the listing for binarySource=install Note: This feature only supports Self-hosting Renovate environment where user have control over the binarySource attribute.\n"},{"id":13,"href":"/hermit/faq/","title":"FAQ","parent":"Hermit","content":" Which Shells Does Hermit work with? powerlevel10k support Does Hermit Manage Libaries? Is Python supported? Is Ruby supported? Why Doesn't Hermit Have a Package for ...? Does the Hermit Project Build and Host its own Packages? How is Hermit different to ...? asdf Bazel Docker GoFish Homebrew Nix Which Shells Does Hermit work with? Hermit currently works with ZSH and BASH, but we would welcome contributions to support other shells.\npowerlevel10k support If you would like powerlevel10k to support hermit, all that is needed is to add the following to your ~/.p10k.zsh\nfunction prompt_hermit() { if [[ -n $HERMIT_ENV ]]; then p10k segment -t \u0026#34;${${HERMIT_ENV:t}//\\%/%%} üêö\u0026#34; -f blue fi } Then you can add the hermit segment to any location. For example:\ntypeset -g POWERLEVEL9K_LEFT_PROMPT_ELEMENTS=( # =========================[ Line #1 ]========================= os_icon # os identifier dir # current directory vcs # git status # =========================[ Line #2 ]========================= newline # \\n hermit prompt_char # prompt symbol ) Does Hermit Manage Libaries? No, Hermit is deliberately not in the business of installing libraries. Hermit is designed to manage development tools only, not be a general purpose package manager. Consider Nix if you need this kind of functionality.\nIs Python supported? Yes!\nHermit sets PYTHONUSERBASE to ${HERMIT_ENV}/.hermit/python and adds ${PYTHONUSERBASE}/bin to the ${PATH} when in an activated environment. This results in packages installed within the environment being mostly (completely?) isolated similar to how virtualenv works.\nIs Ruby supported? Not yet. Hermit only supports static/relocatable binary packages and there are no recent Ruby versions compiled in this way. We would love contributions to support Ruby.\nWhy Doesn't Hermit Have a Package for ...? There could be a number of reasons why a package isn't present in Hermit.\nThe package may not be conducive to self-contained packaging (eg. Python). The community might not have needed one (yet) - please contribute one! Does the Hermit Project Build and Host its own Packages? Yes and no. Mostly no, but some existing upstream binary packages require some level of pre-processing (eg. Python). These are hosted at cashapp/hermit-build.\nHow is Hermit different to ...? asdf Hermit is probably most similar to asdf, but their goals differ. Hermit's goal is to make isolated cross-platform tooling consistent, self-bootstrapping, and reproducible at the project level. asdf's primary goal is to allow developers to install and switch between multiple versions of languages and tooling.\nHermit asdf Compare Packaging HCL manifest Shell script-based plugin API Java in asdf / Java in Hermit. Packages Binary only. Compile from source, binary, wrappers around pyenv, rbenv, etc. Python in asdf / Python in Hermit Limiting Hermit to installing only binary packages has pros and cons:\nFeature Explanation Pro Faster Binary packages don't require compilation, just downloading and unpacking. Con Less choice There are typically less relocatable/static binary packages available. Con Relocatable packages Relocatable/static binary packages can be difficult to build. Pro Less fragile Source installations fail frequently due to missing dependencies, missing tools, and so on. Pro Less requirements Source installations generally require a functional compiler toolchain be already present on your system, such as GCC, clang, etc. Bazel While not really in the same space as Hermit, Bazel does provide build isolation and opt-in hermetic builds. However Bazel also:\nRequires going all-in on Bazel as a build system, whereas Hermit is explicitly not a build system but rather integrates into existing toolchains. Requires completely separate tooling, editor/IDE integration and so on. Docker Docker has a very large community and provides isolation, both of which are appealing. Unfortunately it has several shortcomings which in our view preclude it from use as a day to day development tooling system.\nFilesystem mapping on OSX is very slow. It does not support OSX binaries inside Docker (though see Docker-OSX). Poor integration with host editors/IDEs (though there is some movement). GoFish GoFish's package definitions are quite similar to Hermit's, but GoFish itself:\nDoes not support multiple versions of the same package. Requires root for system wide installation. Does not support the concept of \u0026quot;environments\u0026quot;. Homebrew Homebrew is a full package build system but also:\nIs a system wide package manager. Is largely OSX specific. Does not support concurrent installation of different versions of the same package well. Nix Nix is the package manager for an entire OS and thus provides vastly more functionality than Hermit, including a full package build system. This naturally also comes with a corresponding increase in complexity. Hermit is deliberately designed to be narrow in scope, limited to just installing existing packages.\n"},{"id":14,"href":"/hermit/packaging/","title":"Packaging","parent":"Hermit","content":"Hermit manifests (package definitions) are HCL configuration files defining where to download packages from and how to install them.\nTutorial Reference Private Packages Schema \u0026lt;manifest\u0026gt;.hcl auto-version \u0026gt; html darwin linux channel \u0026lt;name\u0026gt; version \u0026lt;version\u0026gt; on \u0026lt;event\u0026gt; on \u0026gt; chmod on \u0026gt; copy on \u0026gt; delete on \u0026gt; message on \u0026gt; rename on \u0026gt; run platform \u0026lt;attr\u0026gt; version \u0026gt; auto-version "},{"id":15,"href":"/hermit/packaging/tutorial/","title":"Tutorial","parent":"Packaging","content":"For this tutorial we're going to package up jq, a supremely useful tool for filtering and transforming JSON.\nWriting package manifests for Hermit should be fairly familiar to anyone who has had experience with package managers like Homebrew, though it should be significantly more straightforward assuming the package provides cross-platform binaries for download.\nThis tutorial covers a fairly simple package definition, but more complex examples exist such as graalvm. Please refer to the hermit-packages repository for many more examples.\nClone and Activate the Manifest Repository git clone https://github.com/cashapp/hermit-packages cd hermit-packages . ./bin/activate-hermit The Hermit manifest repository is itself a Hermit environment configured to use itself as the source of packages. This makes testing very convenient. Find the Releases The releases for jq are conveniently in a single page and by downloading one of the links we can see that they're directly downloadable binaries. Convenient.\nCreate a Basic Manifest Create an empty jq.hcl file in the hermit-packages directory. The first thing you'll want is a description, for which typically just copy the project description from their site or GitHub repository:\ndescription = \u0026#34;jq is like sed for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that sed, awk, grep and friends let you play with text.\u0026#34; The hermit CLI includes a best-effort command to create a stub manifest.\nhermit manifest create https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64` Currently there a few limitations:\nIt only works for binaries in GitHub releases. The download link must include ${os} and either ${arch} or ${xarch}. Hopefully these limitations will be removed over time.\nAdd a Version version blocks tell Hermit what versions of a package are available for download and are specified as blocks. We'll start with an empty one for jq-1.6:\nversion \u0026#34;1.6\u0026#34; {} Add Download URLs for Each OS Looking at the links we can see that there are downloads for Linux and OSX:\nhttps://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 https://github.com/stedolan/jq/releases/download/jq-1.6/jq-osx-amd64 So we'll add blocks for the respective operating systems (linux and darwin) and populate the source attribute, which tells Hermit where to download packages from:\nversion \u0026#34;1.6\u0026#34; { linux { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\u0026#34; } darwin { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-1.6/jq-osx-amd64\u0026#34; } } DRY our URLs The raw URLs will work fine, but if we add more versions later it would be nice not to have to duplicate this configuration. To do that we can pull the OS blocks out to the top level and use Hermit's variable interpolation support to substitute the ${version} variable:\ndescription = \u0026#34;jq is like sed for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that sed, awk, grep and friends let you play with text.\u0026#34; linux { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-${version}/jq-linux64\u0026#34; } darwin { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-${version}/jq-osx-amd64\u0026#34; } version \u0026#34;1.6\u0026#34; {} When selecting a version/channel, Hermit will look for sources in the matching block and fallback to the top-level.\nSpecifying the Binaries At this point Hermit knows where to download our binaries from, but not what to do with them. The binaries will also have different names(jq-linux64 and jq-osx-amd64) depending on which OS we're on. We need to rename this binaries to the canonical jq. To solve this we're going to need to use a trigger to apply an action when unpacking, specifically the rename action.\nlinux { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-${version}/jq-linux64\u0026#34; on unpack { rename { from = \u0026#34;${root}/jq-linux64\u0026#34; to = \u0026#34;${root}/jq\u0026#34; } } } darwin { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-${version}/jq-osx-amd64\u0026#34; on unpack { rename { from = \u0026#34;${root}/jq-osx-amd64\u0026#34; to = \u0026#34;${root}/jq\u0026#34; } } } And tell Hermit which binaries to link when installed:\nbinaries = [\u0026#34;jq\u0026#34;] The binaries attribute supports globs, which will be expanded at unpack time. Testing the Package Hermit packages can include a testing attribute which is a command to run to test whether the package is functioning. This will typically just be something like:\ntest = \u0026#34;jq --version\u0026#34; The Hermit packages CI will run these tests periodically.\nTo test your package run:\n$ hermit test jq --trace debug:jq-1.6:exec: /Users/user/Library/Caches/hermit/pkg/jq-1.6/jq --version debug: jq-1.6 The End Result And we're done.\ndescription = \u0026#34;jq is like sed for JSON data - you can use it to slice and filter and map and transform structured data with the same ease that sed, awk, grep and friends let you play with text.\u0026#34; binaries = [\u0026#34;jq\u0026#34;] test = \u0026#34;jq --version\u0026#34; linux { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-${version}/jq-linux64\u0026#34; on unpack { rename { from = \u0026#34;${root}/jq-linux64\u0026#34; to = \u0026#34;${root}/jq\u0026#34; } } } darwin { source = \u0026#34;https://github.com/stedolan/jq/releases/download/jq-${version}/jq-osx-amd64\u0026#34; on unpack { rename { from = \u0026#34;${root}/jq-osx-amd64\u0026#34; to = \u0026#34;${root}/jq\u0026#34; } } } version \u0026#34;1.6\u0026#34; {} Local Manual Testing As mentioned above, hermit-packages is also a Hermit environment. Now we have our manifest we can attempt to install it with:\n$ hermit install jq $ jq --version jq-1.6 Distribute the Package At this point you can (and should!) contribute the package back to the community via a PR.\n"},{"id":16,"href":"/hermit/packaging/reference/","title":"Reference","parent":"Packaging","content":" Update Policy Hermit syncs manifest sources every 24 hours from HEAD. Because any changes are then immediately reflected in active environments, care must be taken to maintain backwards compatibility.\nIn particular this means:\nNever delete or rename versions. Take care when updating environment variables. And in general think carefully about what impact your change will have if it is applied to an active environment.\nManifests Hermit manifests (package definitions) are HCL configuration files defining where to download packages from and how to install them.\nRefer to the schema documentation for details.\nHere's an example manifest for Rust:\ndescription = \u0026#34;A language empowering everyone to build reliable and efficient software.\u0026#34; binaries = [\u0026#34;bin/*\u0026#34;] strip = 2 darwin { source = \u0026#34;https://static.rust-lang.org/dist/rust-${version}-x86_64-apple-darwin.tar.xz\u0026#34; } linux { source = \u0026#34;https://static.rust-lang.org/dist/rust-${version}-x86_64-unknown-linux-musl.tar.xz\u0026#34; } version \u0026#34;1.51.0\u0026#34; {} channel nightly { update = \u0026#34;24h\u0026#34; darwin { source = \u0026#34;https://static.rust-lang.org/dist/rust-nightly-x86_64-apple-darwin.tar.xz\u0026#34; } linux { source = \u0026#34;https://static.rust-lang.org/dist/rust-nightly-x86_64-unknown-linux-musl.tar.xz\u0026#34; } } Package source can refer to a remote archive file by using http:// or https:// prefixes, to a local file by using file:// prefix, or to a Git repository by using .git suffix. If the source points to an archive file, it is extracted at installation. Git repositories are cloned from the default branch and used as is.\nSources A manifest source is a location where a set of manifests are stored. Hermit supports manifest sources in Git repositories, local filesystems (useful for temporary overrides while testing packages), and environment-relative.\nMultiple sources can be specified globally by Hermit or per-project, allowing fine-grained control over which package definitions will be used.\nVersions Version blocks are explicitly defined versions of a particular package.\nChannels Channels define a download source that will be automatically checked for updates periodically. Hermit will check the URL's ETag and update the package if there is a newer version.\nAdditionally, Hermit will create several synthetic channels which are checked for updates every 24h:\nA @latest channel pointing at the most recent non-pre-release version. A @\u0026lt;MAJOR\u0026gt; channel for every major version. A @\u0026lt;MAJOR\u0026gt;.\u0026lt;MINOR\u0026gt; channel for every major+minor version. This allows projects to pin to stable releases.\nDependencies Hermit supports two kinds of dependencies between packages, direct dependencies and runtime dependencies.\nDirect dependencies Direct dependencies are declared in the manifest files using a requires definition in the manifest file. This lists the packages that are needed in the environment to use the given package. The package references in the requires list can either refer to an explicit package, or to a value defined in the provides definition of the dependency. For example, requires = [\u0026quot;jre\u0026quot;] would work with any package defining provides = [\u0026quot;jre\u0026quot;] in its definition.\nWhen a package with requires definition is installed, all its dependencies are installed to the target environment as well.\nRuntime dependencies Runtime dependencies are package dependencies that are not installed into the target environment. These are defined using a runtime-dependencies definition in the manifest.\nHermit makes sure the runtime dependencies are on the system when a binary from the package is executed, and injects the environment variables from the runtime dependencies to the binary when executed. This is a good way on depending on binaries and env variables from other packages in your package without exposing them to the target environment.\nVariable Interpolation Hermit manifests support basic variable interpolation to simplify configuration. It's not necessary to utilise them, but they can make life simpler in many cases.\nThe available variables are:\nVariable Description name The name of the current package. version The version selected by the user. Does not apply when installing a channel. dest The directory where the archive will be extracted. Defaults to \u0026lt;hermit-state\u0026gt;/pkg/\u0026lt;pkg-selector\u0026gt;. root Directory considered the package root. Defaults to ${dest}. os The system's OS as reported by Go. arch The system's CPU architecture as reported by Go. xarch An alternate mapping of ${arch} where amd64=\u0026gt;x86_64, i386=\u0026gt;386, and arm64=\u0026gt;aarch64. HERMIT_ENV Path to the active Hermit environment. HERMIT_BIN Path to the active Hermit environment's bin directory. HOME The user's home directory. Triggers and Actions Hermit supports the concept of triggers and actions which can be applied when certain events occur in the package lifecycle. Supported events are:\nEvent Description unpack Triggered when a package is unpacked into the Hermit cache. install Triggered when a package is installed into an environment. activate Triggered when the environment the package is installed in is activated. More triggers may be added in the future.\n"},{"id":17,"href":"/hermit/packaging/private/","title":"Private Packages","parent":"Packaging","content":" Custom Hermit Hermit has a configurable command-line entry point which can be useful if you need to use a custom HTTP client in order to access your private packages or manifest sources. See the hermit main package for an example of how this is used.\nThis can be used to specify a custom set of sources, and other configuration, for your org.\nPrivate Channel If you ship your own version of Hermit you must choose a unique channel name (typically your oganisation's name), eg. For Square this would be square. If you don't choose a unique channel your users may end up using the public Hermit accidentally, creating confusion.\nInstaller Script The Hermit installer requires the parent path component of its install URL to be the same as the channel name. A custom install.sh can be generated by cmd/geninstaller:\ngeninstaller --dest=install.sh --dist-url=https://mycompany.com/mycompany/hermit-install.sh Private GitHub Releases Private GitHub Releases can be accessed with a Personal Access Token, an OAuth token or a GitHub App installation token. This token must have the repo scope set at creation.\nThe environment variable HERMIT_GITHUB_TOKEN must be set to this a token.\n"},{"id":18,"href":"/hermit/packaging/schema/","title":"Schema","parent":"Packaging","content":"Each Hermit package manifest is a nested structure containing OS/architecture-specific configuration.\nThis is reference documentation for the manifest structure. Refer to the tutorial for a guided introduction and existing manifests for examples.\nTable of Contents \u0026lt;manifest\u0026gt;.hcl auto-version \u0026gt; html darwin linux channel \u0026lt;name\u0026gt; version \u0026lt;version\u0026gt; on \u0026lt;event\u0026gt; on \u0026gt; chmod on \u0026gt; copy on \u0026gt; delete on \u0026gt; message on \u0026gt; rename on \u0026gt; run platform \u0026lt;attr\u0026gt; version \u0026gt; auto-version "},{"id":19,"href":"/hermit/packaging/schema/manifest/","title":"\u003cmanifest\u003e.hcl","parent":"Schema","content":"Each Hermit package manifest is a nested structure containing OS/architecture-specific configuration.\nBlocks Block Description channel \u0026lt;name\u0026gt; { ‚Ä¶ } Definition of and configuration for an auto-update channel. darwin { ‚Ä¶ } Darwin-specific configuration. linux { ‚Ä¶ } Linux-specific configuration. on \u0026lt;event\u0026gt; { ‚Ä¶ } Triggers to run on lifecycle events. platform \u0026lt;attr\u0026gt; { ‚Ä¶ } Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc.. version \u0026lt;version\u0026gt; { ‚Ä¶ } Definition of and configuration for a specific version. Attributes Attribute Type Description apps [string]? Relative paths to Mac .app packages to install. arch string? CPU architecture to match (amd64, 386, arm, etc.). binaries [string]? Relative glob from $root to individual terminal binaries. default string? Default version or channel if not specified. description string Human readable description of the package. dest string? Override archive extraction destination for package. env {string: string}? Environment variables to export. files {string: string}? Files to load strings from to be used in the manifest. homepage string? Home page. mirrors [string]? Mirrors to use if the primary source is unavailable. mutable boolean? Package will not be made read-only. provides [string]? This package provides the given virtual packages. rename {string: string}? Rename files after unpacking to ${root}. repository string? Source Repository. requires [string]? Packages this one requires. root string? Override root for package. runtime-dependencies [string]? Packages used internally by this package, but not installed to the target environment sha256 string? SHA256 of source package for verification. When in conflict with SHA256 in sha256sums, this value takes precedence. sha256sums {string: string}? SHA256 checksums of source packages for verification. source string? URL for source package. Valid URLs are Git repositories (using .git[#\u0026lt;tag\u0026gt;] suffix), Local Files (using file:// prefix), and Remote Files (using http:// or https:// prefix) strip number? Number of path prefix elements to strip. test string? Command that will test the package is operational. vars {string: string}? Set local variables used during manifest evaluation. "},{"id":20,"href":"/hermit/packaging/schema/html/","title":"auto-version \u003e html","parent":"Schema","content":"Extract version information from a HTML URL using XPath.\nUsed by: auto-version\nAttributes Attribute Type Description url string URL to retrieve HTML from. xpath string XPath for extracting versions from HTML (see https://github.com/antchfx/htmlquery) "},{"id":21,"href":"/hermit/packaging/schema/darwin/","title":"darwin","parent":"Schema","content":"Darwin-specific configuration.\nUsed by: channel linux \u0026lt;manifest\u0026gt; platform version\nBlocks Block Description darwin { ‚Ä¶ } Darwin-specific configuration. linux { ‚Ä¶ } Linux-specific configuration. on \u0026lt;event\u0026gt; { ‚Ä¶ } Triggers to run on lifecycle events. platform { ‚Ä¶ } Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc.. Attributes Attribute Type Description apps [string]? Relative paths to Mac .app packages to install. arch string? CPU architecture to match (amd64, 386, arm, etc.). binaries [string]? Relative glob from $root to individual terminal binaries. dest string? Override archive extraction destination for package. env {string: string}? Environment variables to export. files {string: string}? Files to load strings from to be used in the manifest. mirrors [string]? Mirrors to use if the primary source is unavailable. mutable boolean? Package will not be made read-only. provides [string]? This package provides the given virtual packages. rename {string: string}? Rename files after unpacking to ${root}. requires [string]? Packages this one requires. root string? Override root for package. runtime-dependencies [string]? Packages used internally by this package, but not installed to the target environment sha256 string? SHA256 of source package for verification. When in conflict with SHA256 in sha256sums, this value takes precedence. sha256sums {string: string}? SHA256 checksums of source packages for verification. source string? URL for source package. Valid URLs are Git repositories (using .git[#\u0026lt;tag\u0026gt;] suffix), Local Files (using file:// prefix), and Remote Files (using http:// or https:// prefix) strip number? Number of path prefix elements to strip. test string? Command that will test the package is operational. vars {string: string}? Set local variables used during manifest evaluation. "},{"id":22,"href":"/hermit/packaging/schema/linux/","title":"linux","parent":"Schema","content":"Linux-specific configuration.\nUsed by: channel darwin \u0026lt;manifest\u0026gt; platform version\nBlocks Block Description darwin { ‚Ä¶ } Darwin-specific configuration. linux { ‚Ä¶ } Linux-specific configuration. on \u0026lt;event\u0026gt; { ‚Ä¶ } Triggers to run on lifecycle events. platform { ‚Ä¶ } Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc.. Attributes Attribute Type Description apps [string]? Relative paths to Mac .app packages to install. arch string? CPU architecture to match (amd64, 386, arm, etc.). binaries [string]? Relative glob from $root to individual terminal binaries. dest string? Override archive extraction destination for package. env {string: string}? Environment variables to export. files {string: string}? Files to load strings from to be used in the manifest. mirrors [string]? Mirrors to use if the primary source is unavailable. mutable boolean? Package will not be made read-only. provides [string]? This package provides the given virtual packages. rename {string: string}? Rename files after unpacking to ${root}. requires [string]? Packages this one requires. root string? Override root for package. runtime-dependencies [string]? Packages used internally by this package, but not installed to the target environment sha256 string? SHA256 of source package for verification. When in conflict with SHA256 in sha256sums, this value takes precedence. sha256sums {string: string}? SHA256 checksums of source packages for verification. source string? URL for source package. Valid URLs are Git repositories (using .git[#\u0026lt;tag\u0026gt;] suffix), Local Files (using file:// prefix), and Remote Files (using http:// or https:// prefix) strip number? Number of path prefix elements to strip. test string? Command that will test the package is operational. vars {string: string}? Set local variables used during manifest evaluation. "},{"id":23,"href":"/hermit/packaging/schema/channel/","title":"channel \u003cname\u003e","parent":"Schema","content":"Definition of and configuration for an auto-update channel.\nUsed by: \u0026lt;manifest\u0026gt;\nBlocks Block Description darwin { ‚Ä¶ } Darwin-specific configuration. linux { ‚Ä¶ } Linux-specific configuration. on \u0026lt;event\u0026gt; { ‚Ä¶ } Triggers to run on lifecycle events. platform \u0026lt;attr\u0026gt; { ‚Ä¶ } Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc.. Attributes Attribute Type Description apps [string]? Relative paths to Mac .app packages to install. arch string? CPU architecture to match (amd64, 386, arm, etc.). binaries [string]? Relative glob from $root to individual terminal binaries. dest string? Override archive extraction destination for package. env {string: string}? Environment variables to export. files {string: string}? Files to load strings from to be used in the manifest. mirrors [string]? Mirrors to use if the primary source is unavailable. mutable boolean? Package will not be made read-only. provides [string]? This package provides the given virtual packages. rename {string: string}? Rename files after unpacking to ${root}. requires [string]? Packages this one requires. root string? Override root for package. runtime-dependencies [string]? Packages used internally by this package, but not installed to the target environment sha256 string? SHA256 of source package for verification. When in conflict with SHA256 in sha256sums, this value takes precedence. sha256sums {string: string}? SHA256 checksums of source packages for verification. source string? URL for source package. Valid URLs are Git repositories (using .git[#\u0026lt;tag\u0026gt;] suffix), Local Files (using file:// prefix), and Remote Files (using http:// or https:// prefix) strip number? Number of path prefix elements to strip. test string? Command that will test the package is operational. update string Update frequency for this channel. vars {string: string}? Set local variables used during manifest evaluation. version string? Use the latest version matching this version glob as the source of this channel. Empty string matches all versions "},{"id":24,"href":"/hermit/packaging/schema/version/","title":"version \u003cversion\u003e","parent":"Schema","content":"Definition of and configuration for a specific version.\nUsed by: \u0026lt;manifest\u0026gt;\nBlocks Block Description auto-version { ‚Ä¶ } Automatically update versions. darwin { ‚Ä¶ } Darwin-specific configuration. linux { ‚Ä¶ } Linux-specific configuration. on \u0026lt;event\u0026gt; { ‚Ä¶ } Triggers to run on lifecycle events. platform \u0026lt;attr\u0026gt; { ‚Ä¶ } Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc.. Attributes Attribute Type Description apps [string]? Relative paths to Mac .app packages to install. arch string? CPU architecture to match (amd64, 386, arm, etc.). binaries [string]? Relative glob from $root to individual terminal binaries. dest string? Override archive extraction destination for package. env {string: string}? Environment variables to export. files {string: string}? Files to load strings from to be used in the manifest. mirrors [string]? Mirrors to use if the primary source is unavailable. mutable boolean? Package will not be made read-only. provides [string]? This package provides the given virtual packages. rename {string: string}? Rename files after unpacking to ${root}. requires [string]? Packages this one requires. root string? Override root for package. runtime-dependencies [string]? Packages used internally by this package, but not installed to the target environment sha256 string? SHA256 of source package for verification. When in conflict with SHA256 in sha256sums, this value takes precedence. sha256sums {string: string}? SHA256 checksums of source packages for verification. source string? URL for source package. Valid URLs are Git repositories (using .git[#\u0026lt;tag\u0026gt;] suffix), Local Files (using file:// prefix), and Remote Files (using http:// or https:// prefix) strip number? Number of path prefix elements to strip. test string? Command that will test the package is operational. vars {string: string}? Set local variables used during manifest evaluation. "},{"id":25,"href":"/hermit/packaging/schema/on/","title":"on \u003cevent\u003e","parent":"Schema","content":"Triggers to run on lifecycle events.\nUsed by: channel darwin linux \u0026lt;manifest\u0026gt; platform version\nBlocks Block Description chmod { ‚Ä¶ } Change a files mode. copy { ‚Ä¶ } A file to copy when the event is triggered. delete { ‚Ä¶ } Delete files. message { ‚Ä¶ } Display a message to the user. rename { ‚Ä¶ } Rename a file. run { ‚Ä¶ } A command to run when the event is triggered. "},{"id":26,"href":"/hermit/packaging/schema/chmod/","title":"on \u003e chmod","parent":"Schema","content":"Change a files mode.\nUsed by: on\nAttributes Attribute Type Description file string File to set mode on. mode number File mode to set. "},{"id":27,"href":"/hermit/packaging/schema/copy/","title":"on \u003e copy","parent":"Schema","content":"A file to copy when the event is triggered.\nUsed by: on\nAttributes Attribute Type Description from string The source file to copy from. Absolute paths reference the file system while relative paths are against the manifest source bundle. mode number? File mode of file. to string The relative destination to copy to, based on the context. "},{"id":28,"href":"/hermit/packaging/schema/delete/","title":"on \u003e delete","parent":"Schema","content":"Delete files.\nUsed by: on\nAttributes Attribute Type Description files [string] Files to delete. recursive boolean? Recursively delete. "},{"id":29,"href":"/hermit/packaging/schema/message/","title":"on \u003e message","parent":"Schema","content":"Display a message to the user.\nUsed by: on\nAttributes Attribute Type Description text string Message text to display to user. "},{"id":30,"href":"/hermit/packaging/schema/rename/","title":"on \u003e rename","parent":"Schema","content":"Rename a file.\nUsed by: on\nAttributes Attribute Type Description from string Source path to rename. to string Destination path to rename to. "},{"id":31,"href":"/hermit/packaging/schema/run/","title":"on \u003e run","parent":"Schema","content":"A command to run when the event is triggered.\nUsed by: on\nAttributes Attribute Type Description args [string]? The arguments to the binary. cmd string The command to execute, split by shellquote. dir string? The directory where the command is run. Defaults to the ${root} directory. env [string]? The environment variables for the execution. stdin string? Optional string to be used as the stdin for the command. "},{"id":32,"href":"/hermit/packaging/schema/platform/","title":"platform \u003cattr\u003e","parent":"Schema","content":"Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc..\nUsed by: channel darwin linux \u0026lt;manifest\u0026gt; version\nBlocks Block Description darwin { ‚Ä¶ } Darwin-specific configuration. linux { ‚Ä¶ } Linux-specific configuration. on \u0026lt;event\u0026gt; { ‚Ä¶ } Triggers to run on lifecycle events. platform { ‚Ä¶ } Platform-specific configuration. \u0026lt;attr\u0026gt; is a set regexes that must all match against one of CPU, OS, etc.. Attributes Attribute Type Description apps [string]? Relative paths to Mac .app packages to install. arch string? CPU architecture to match (amd64, 386, arm, etc.). binaries [string]? Relative glob from $root to individual terminal binaries. dest string? Override archive extraction destination for package. env {string: string}? Environment variables to export. files {string: string}? Files to load strings from to be used in the manifest. mirrors [string]? Mirrors to use if the primary source is unavailable. mutable boolean? Package will not be made read-only. provides [string]? This package provides the given virtual packages. rename {string: string}? Rename files after unpacking to ${root}. requires [string]? Packages this one requires. root string? Override root for package. runtime-dependencies [string]? Packages used internally by this package, but not installed to the target environment sha256 string? SHA256 of source package for verification. When in conflict with SHA256 in sha256sums, this value takes precedence. sha256sums {string: string}? SHA256 checksums of source packages for verification. source string? URL for source package. Valid URLs are Git repositories (using .git[#\u0026lt;tag\u0026gt;] suffix), Local Files (using file:// prefix), and Remote Files (using http:// or https:// prefix) strip number? Number of path prefix elements to strip. test string? Command that will test the package is operational. vars {string: string}? Set local variables used during manifest evaluation. "},{"id":33,"href":"/hermit/packaging/schema/auto-version/","title":"version \u003e auto-version","parent":"Schema","content":"Automatically update versions.\nUsed by: version\nBlocks Block Description html { ‚Ä¶ } Extract version information from a HTML URL using XPath. Attributes Attribute Type Description github-release string? GitHub \u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt; to retrieve and update versions from the releases API. version-pattern string? Regex with one capture group to extract the version number from the origin. "},{"id":34,"href":"/hermit/about/","title":"About","parent":"Hermit","content":"Hermit was created at CashApp (Square) by Alec Thomas and Juho M√§kinen of the Cash Cloud Platform team, with contributions by many others whose feedback is very much appreciated.\nThe source code for Hermit is here. The default open source set of package manifests is here.\nFor discussions find us on the #cashapp channel on Gophers Slack.\n"},{"id":35,"href":"/hermit/","title":"Hermit","parent":"","content":" Hermit manages isolated, self-bootstrapping sets of tools in software projects. Hermit ensures that your team, your contributors, and your CI have the same consistent tooling. Packages installed via Hermit will be available on any future machine, Linux or Mac, by simply cloning the repository and running the linked binaries. Each link will bootstrap Hermit if necessary, then auto-install the package, before executing the binary. Get Started Why Do I Need it? If you've ever had to add something like the following to your project's README...\nMake sure you have at least Node 12.x.y, protoc x.y.z, GNU make version 4.x.y, and Go 1.16 or higher.\n...then Hermit is for you.\nExample Quickstart Run this command and follow the instructions:\ncurl -fsSL https://github.com/cashapp/hermit/releases/download/stable/install.sh | /bin/bash Packages Default packages are available here. Source code Contributions are welcome here. Problems? Please file an issue and we'll look into it. "}]